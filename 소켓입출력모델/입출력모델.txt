소켓 입출력 모델(Socket I/O model)은 다수의 소켓을 관리하고 소켓에 대한 입출력을 처리하는 방식을 뜻한다.

소켓 입출력 모델을 사용하면 복잡도는 높아지지만 시스템 자원을
적게 사용하면서도 다수의 클라이언트를 효율적으로 처리하는 서버를 만들 수 있다.

이 절에서는 소켓 입출력 모델을 학습하기 위한 사전 지식으로 소켓의 동작 모드를 알아보고,
윈도우 운영체제가 제공하는 다양한 소켓 입출력 모델의 종류를 살펴본다.

소켓 모드의 종류
- 소켓은 소켓 함수 호출 시 동작하는 방식에 따라 블로킹과 넌블로킹 소켓으로 구분한다. 이를 소켓 모드(Socket Mode)라고 부르며,
 각각의 특징은 다음과 같다.

==========================================================================================

블로킹 소켓
 - 소켓 함수 호출 시 조건을 만족하지 않으면 함수가 리턴하지 않고 스레드가 정지된다.
 - 소켓 함수가 리턴하지 않으므로 응용 프로그램이 별도의 스레드를 사용하지 않는 한 다른 작업을 할 수 없다.
 - 소켓 함수란, accept, connect, recv(from), send(to) 등이 있다.

각 함수가 리턴하는 시기는 다음과 같다.
accept() : 접속한 클라이언트가 있을 때
connect() : 서버에 접속이 성공했을 때
send(to)() : 응용 프로그램이 전송을 요청한 데이터를 소켓 송신 버퍼에 모두 복사했을 때
recv(from)() : (TCP) 소켓 수신 버퍼에 도착한 데이터가 1바이트 이상 있어서 이를 응용 프로그램이 제공한 버퍼에 복사했을 때
		: (UDP) UDP 패킷이 완전히 도착해서 소켓 수신 버퍼의 UDP 데이터를 응용 프로그램이 제공한 버퍼에 복사했을 때

==========================================================================================

넌블로킹 소켓
 - 소켓 함수 호출 시 조건을 만족하지 않아도 함수가 바로 리턴하므로 스레드가 중단되지 않는다.
 - 예를 들어, 접속한 클라이언트가 없어도 accept 함수가 리턴하고, 소켓 수신 버퍼에 도착한 데이터가 없어도 recv()가 리턴한다.


socket() 함수는 기본적으로 블로킹 소켓을 생성한다.
넌블로킹 소켓이 필요하다면 다음 함수를 사용하여 소켓 모드를 변환해야 한다.

> u_long on = 1;
> ioctlsocket(sock, FIONBIO, &on);


넌블로킹 소켓에 대해 소켓 함수 호출 시 조건을 만족하지 않으면 소켓 함수는 오류를 리턴한다.
이때는 WSAGetLastError()로 오류코드를 확인한다.
대개 오류코드는 WSAEWOULDBLOCK 이며, 조건을 만족하지 않았음을 나타낸다.
나중에 다시 소켓 함수를 호출하면 해결된다.